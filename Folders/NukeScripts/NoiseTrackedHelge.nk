set cut_paste_input [stack 0]
version 10.5 v5
push $cut_paste_input
Group {
name Group13
autolabel 'PositionNoiseRGB'
note_font_size 12
selected true
xpos -9989
ypos 570
addUserKnob {20 User}
addUserKnob {26 in l " " T "Expects position in rgb, alpha optional.\n \n"}
addUserKnob {41 translate T a_transScale.translate}
addUserKnob {41 rotate T a_transScale.rotate}
addUserKnob {41 scaling l scale T a_transScale.scaling}
addUserKnob {41 pivot T a_transScale.pivot}
addUserKnob {41 uniform_scale_1 l "uniform scale" T a_transScale.uniform_scale}
addUserKnob {22 link l "link to selected Axis" T "n = nuke.thisGroup()\nn.end()\na = nuke.selectedNode()\naName = a.name()\nn\['translate'].setExpression(aName+'.translate')\nn\['rotate'].setExpression(aName+'.rotate')\nn\['scaling'].setExpression(aName+'.scaling')\nn\['pivot'].setExpression(aName+'.pivot')\nn\['uniform_scale_1'].setExpression(aName+'.uniform_scale')" +STARTLINE}
addUserKnob {26 ""}
addUserKnob {4 type l "noise type" M {fBm turbulence Worley "Worley regular" Voronoi "Voronoi regular" Manhattan "Manhattan regular" Euclidian "Euclidian regular" ChebyShev "ChebyShev regular" "" "" ""}}
type "Voronoi regular"
addUserKnob {7 lu l lucanarity t "for fBm and turbulence" R 1 3}
lu 1.755
addUserKnob {7 oc l octaves t "for fBm and turbulence" R 0 10}
oc 10
addUserKnob {7 ga l gain t "for fBm and turbulence"}
ga 0.515
addUserKnob {7 range t "for Voronoi, Manhattan, Euclidian, ChebyShev" R 0 10}
range 4.3
addUserKnob {22 reset t "reset noise parameters to a good start" T "n = nuke.thisNode()\nn\['lu'].setValue(2)\nn\['oc'].setValue(10)\nn\['ga'].setValue(0.5)\nn\['range'].setValue(5)" +STARTLINE}
addUserKnob {26 ""}
addUserKnob {20 grade n 1}
addUserKnob {41 blackpoint T Grade_post.blackpoint}
addUserKnob {41 whitepoint T Grade_post.whitepoint}
addUserKnob {41 black l lift T Grade_post.black}
addUserKnob {41 white l gain T Grade_post.white}
addUserKnob {41 multiply T Grade_post.multiply}
addUserKnob {41 add l offset T Grade_post.add}
addUserKnob {41 gamma T Grade_post.gamma}
addUserKnob {41 black_clamp l "black clamp" T Grade_post.black_clamp}
addUserKnob {41 white_clamp l "white clamp" -STARTLINE T Grade_post.white_clamp}
addUserKnob {20 endGroup n -1}
addUserKnob {26 ""}
addUserKnob {6 absolute t "no negative values." +STARTLINE}
addUserKnob {6 clamp -STARTLINE}
addUserKnob {6 invert -STARTLINE}
addUserKnob {6 unpremult l (un)premult -STARTLINE}
addUserKnob {6 keepAlpha l "keep alpha" t "keep your incoming alpha" -STARTLINE}
addUserKnob {6 gpu -STARTLINE}
gpu true
addUserKnob {6 mono t "uses red on rgba" +STARTLINE}
mono true
addUserKnob {6 red -STARTLINE}
addUserKnob {6 green -STARTLINE}
addUserKnob {6 blue -STARTLINE}
addUserKnob {6 alpha -STARTLINE}
addUserKnob {26 info l " " t "v01: init\n\n-- assebled by hst 06/18" T "\nPosition Noise RGB v01"}
}
BackdropNode {
inputs 0
name BackdropNode1
tile_color 0x3d7a9601
label worley
note_font "Helvetica bold Bold Bold Bold Bold Bold"
note_font_size 30
xpos -465
ypos 797
bookmark false
bdwidth 548
bdheight 476
}
BackdropNode {
inputs 0
name BackdropNode10
tile_color 0x3d7a9601
label "ChebyShev regular"
note_font "Helvetica bold Bold Bold Bold Bold Bold Bold Bold Bold Bold Bold"
note_font_size 30
xpos 5156
ypos 763
bookmark false
bdwidth 548
bdheight 476
}
BackdropNode {
inputs 0
name BackdropNode2
tile_color 0x3d7a9601
label "worley regular"
note_font "Helvetica bold Bold Bold Bold Bold Bold Bold"
note_font_size 30
xpos 144
ypos 802
bookmark false
bdwidth 548
bdheight 476
}
BackdropNode {
inputs 0
name BackdropNode3
tile_color 0x3d7a9601
label voronoi
note_font "Helvetica bold Bold Bold Bold Bold Bold Bold"
note_font_size 30
xpos 851
ypos 800
bookmark false
bdwidth 548
bdheight 476
}
BackdropNode {
inputs 0
name BackdropNode4
tile_color 0x3d7a9601
label "voronoi regular"
note_font "Helvetica bold Bold Bold Bold Bold Bold Bold Bold"
note_font_size 30
xpos 1501
ypos 800
bookmark false
bdwidth 548
bdheight 476
}
BackdropNode {
inputs 0
name BackdropNode5
tile_color 0x3d7a9601
label manhattan
note_font "Helvetica bold Bold Bold Bold Bold Bold Bold Bold"
note_font_size 30
xpos 2089
ypos 791
bookmark false
bdwidth 548
bdheight 476
}
BackdropNode {
inputs 0
name BackdropNode6
tile_color 0x3d7a9601
label "manhattan regular"
note_font "Helvetica bold Bold Bold Bold Bold Bold Bold Bold Bold"
note_font_size 30
xpos 2689
ypos 794
bookmark false
bdwidth 548
bdheight 476
}
BackdropNode {
inputs 0
name BackdropNode7
tile_color 0x3d7a9601
label euclidian
note_font "Helvetica bold Bold Bold Bold Bold Bold Bold Bold Bold"
note_font_size 30
xpos 3273
ypos 779
bookmark false
bdwidth 548
bdheight 476
}
BackdropNode {
inputs 0
name BackdropNode8
tile_color 0x3d7a9601
label "euclidian regular"
note_font "Helvetica bold Bold Bold Bold Bold Bold Bold Bold Bold Bold"
note_font_size 30
xpos 3880
ypos 775
bookmark false
bdwidth 548
bdheight 476
}
BackdropNode {
inputs 0
name BackdropNode9
tile_color 0x3d7a9601
label ChebyShev
note_font "Helvetica bold Bold Bold Bold Bold Bold Bold Bold Bold Bold"
note_font_size 30
xpos 4537
ypos 769
bookmark false
bdwidth 548
bdheight 476
}
Axis2 {
inputs 0
display off
selectable false
name a_transScale
xpos -402
ypos 501
}
Input {
inputs 0
name pos
xpos -925
ypos 332
}
set N1bd85310 [stack 0]
Unpremult {
name Unpremult1
xpos -925
ypos 431
disable {{!parent.unpremult}}
}
set N20030550 [stack 0]
Dot {
name Dot31
tile_color 0xd8d8d8ff
note_font_size 20
xpos -1202
ypos 470
}
Dot {
name Dot30
tile_color 0xd8d8d8ff
note_font_size 20
xpos -1202
ypos 2200
}
set N2002e080 [stack 0]
push $N2002e080
push $N20030550
Grade {
add {{-parent.a_transScale.pivot} {-parent.a_transScale.pivot} {-parent.a_transScale.pivot} 0}
black_clamp false
name Grade3
label toZero
xpos -925
ypos 509
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
ColorMatrix {
matrix {
    {{parent.a_transScale.world_matrix.0} {parent.a_transScale.world_matrix.1} {parent.a_transScale.world_matrix.2}}
    {{parent.a_transScale.world_matrix.4} {parent.a_transScale.world_matrix.5} {parent.a_transScale.world_matrix.6}}
    {{parent.a_transScale.world_matrix.8} {parent.a_transScale.world_matrix.9} {parent.a_transScale.world_matrix.10}}
  }
invert true
name ColorMatrix1
label "scale rotate"
xpos -916
ypos 573
addUserKnob {20 User}
addUserKnob {1 target l "target Camera"}
target a_transScale
addUserKnob {22 link T "n = nuke.thisNode()\ntarget = n\['target'].getValue()\nprint 'link to: ' + target\nn\['matrix'].setExpression('parent.'+target+'.world_matrix.0', 0)\nn\['matrix'].setExpression('parent.'+target+'.world_matrix.1', 1)\nn\['matrix'].setExpression('parent.'+target+'.world_matrix.2', 2)\nn\['matrix'].setExpression('parent.'+target+'.world_matrix.4', 3)\nn\['matrix'].setExpression('parent.'+target+'.world_matrix.5', 4)\nn\['matrix'].setExpression('parent.'+target+'.world_matrix.6', 5)\nn\['matrix'].setExpression('parent.'+target+'.world_matrix.8', 6)\nn\['matrix'].setExpression('parent.'+target+'.world_matrix.9', 7)\nn\['matrix'].setExpression('parent.'+target+'.world_matrix.10', 8)" +STARTLINE}
}
Grade {
add {{-parent.a_transScale.translate.x} {-parent.a_transScale.translate.y} {-parent.a_transScale.translate.z} {curve}}
black_clamp false
name Grade1
label translate
xpos -916
ypos 620
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
Grade {
add {{parent.a_transScale.pivot} {parent.a_transScale.pivot} {parent.a_transScale.pivot} {curve}}
black_clamp false
name Grade4
label back
xpos -916
ypos 685
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
set N249599b0 [stack 0]
Dot {
name Dot3
tile_color 0xd8d8d8ff
note_font_size 20
xpos -427
ypos 689
}
set N200237d0 [stack 0]
Dot {
name Dot5
tile_color 0xd8d8d8ff
note_font_size 20
xpos 182
ypos 689
}
set N186d37a0 [stack 0]
Dot {
name Dot6
tile_color 0xd8d8d8ff
note_font_size 20
xpos 1200
ypos 689
}
set N1eaed8a0 [stack 0]
Dot {
name Dot9
tile_color 0xd8d8d8ff
note_font_size 20
xpos 1740
ypos 689
}
set N249b1650 [stack 0]
Dot {
name Dot14
tile_color 0xd8d8d8ff
note_font_size 20
xpos 2166
ypos 689
}
set N16a1e5b0 [stack 0]
Dot {
name Dot12
tile_color 0xd8d8d8ff
note_font_size 20
xpos 2766
ypos 689
}
set N16a22e60 [stack 0]
Dot {
name Dot19
tile_color 0xd8d8d8ff
note_font_size 20
xpos 3350
ypos 699
}
set N1a7594f0 [stack 0]
Dot {
name Dot22
tile_color 0xd8d8d8ff
note_font_size 20
xpos 3957
ypos 699
}
set N1a75df00 [stack 0]
Dot {
name Dot24
tile_color 0xd8d8d8ff
note_font_size 20
xpos 4614
ypos 699
}
set N1d18bc50 [stack 0]
Dot {
name Dot27
tile_color 0xd8d8d8ff
note_font_size 20
xpos 5233
ypos 699
}
Dot {
name Dot26
tile_color 0xd8d8d8ff
note_font_size 20
xpos 5233
ypos 868
}
set N2492ae10 [stack 0]
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ChebyshevNoise\" iterate pixelWise 9b7bb5baffea01f2815b43ed568bc5cc70ddd62141c742f57b3cc33855f38778 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ChebyshevNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ChebyshevDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ChebyshevNoise_Range {{parent.range}}
"ChebyshevNoise_Dark Colour" 0
ChebyshevNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ChebyShevNoise_regular
xpos 5482
ypos 967
}
set N200095f0 [stack 0]
push $N1d18bc50
Dot {
name Dot25
tile_color 0xd8d8d8ff
note_font_size 20
xpos 4614
ypos 874
}
set N2666a170 [stack 0]
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ChebyshevNoise\" iterate pixelWise 85a52ef4d1a8167ec6dc1283c729ab1cebc7895c1963da297b84e031adebfc77 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ChebyshevNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ChebyshevDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ChebyshevNoise_Range {{parent.range}}
"ChebyshevNoise_Dark Colour" 0
ChebyshevNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ChebyShevNoise
xpos 4863
ypos 973
}
set N2666ed40 [stack 0]
push $N1a75df00
Dot {
name Dot21
tile_color 0xd8d8d8ff
note_font_size 20
xpos 3957
ypos 880
}
set N2668e7d0 [stack 0]
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"EuclidianNoise\" iterate pixelWise c55ec03f12f9faefbc24529f012b5eb5c846a72925b427780cae8ed378c3d24d 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel EuclidianNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, EuclidianDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
EuclidianNoise_Range {{parent.range}}
"EuclidianNoise_Dark Colour" 0
group_EuclidianNoise_transform 1
EuclidianNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name EuclidianNoise_regular
xpos 4206
ypos 981
}
set N26693200 [stack 0]
push $N1a7594f0
Dot {
name Dot18
tile_color 0xd8d8d8ff
note_font_size 20
xpos 3350
ypos 882
}
set N266b2bb0 [stack 0]
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"EuclidianNoise\" iterate pixelWise 1414320004d60e120c3e4be78e8c70f632ef4ec8610d7c7bfa0059d00c22cb3b 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel EuclidianNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, EuclidianDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
EuclidianNoise_Range {{parent.range}}
"EuclidianNoise_Dark Colour" 0
EuclidianNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name EuclidianNoise
xpos 3599
ypos 983
}
set N266b7670 [stack 0]
push $N16a22e60
Dot {
name Dot16
tile_color 0xd8d8d8ff
note_font_size 20
xpos 2766
ypos 899
}
set N266d6f60 [stack 0]
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ManhattanNoise\" iterate pixelWise 481093b9fb1fdf55fde93ad91bb68b66d5e638e3c90db7d2cb795eb4769cedbb 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ManhattanNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ManhattanDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ManhattanNoise_Range {{parent.range}}
"ManhattanNoise_Dark Colour" 0
group_ManhattanNoise_transform 1
ManhattanNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ManhattanNoise_regular
xpos 3015
ypos 1000
}
set N266dbb80 [stack 0]
push $N16a1e5b0
Dot {
name Dot13
tile_color 0xd8d8d8ff
note_font_size 20
xpos 2166
ypos 896
}
set N266fb610 [stack 0]
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ManhattanNoise\" iterate pixelWise 49f23d9559c77c47334f4a66696975b65295024e1667d6c7704aa4fe9a12efb2 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ManhattanNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ManhattanDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ManhattanNoise_Range {{parent.range}}
"ManhattanNoise_Dark Colour" 0
group_ManhattanNoise_transform 1
ManhattanNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ManhattanNoise
xpos 2415
ypos 997
}
set N266fff30 [stack 0]
push $N249b1650
Dot {
name Dot8
tile_color 0xd8d8d8ff
note_font_size 20
xpos 1740
ypos 906
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"VoronoiNoise\" iterate pixelWise fed41c7dbe7477aabb1d03f24ef597f7d477dff9168162506c1d00093c602cb5 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], int idArr\[], float value, int id)\n\{\n  float temp;\n  int tempID;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    tempID = idArr\[i];\n    arr\[i] = value;\n    idArr\[i] = id;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n      idArr\[i + 1] = tempID;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel VoronoiNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n    int idArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            id = lastRandom;\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, idArray, length(input - featurePoint), id+l);\n            \}\n        \}\n      \}\n    \}\n\n    float3 col = float3(float(idArray\[iRange]) / rand_modulus, 0.0f, 0.0f);\n    lastRandom = lcgRandom(idArray\[iRange]);\n    col.y = float(lastRandom) / rand_modulus;\n    lastRandom = lcgRandom(lastRandom);\n    col.z = float(lastRandom) / rand_modulus;\n\n    for(int component = 0; component < 3; component++)\n      dst(component) = pow( col\[component] * gain, gamma);\n    dst(3) = 1.0f;\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
VoronoiNoise_Range {{parent.range}}
"VoronoiNoise_Dark Colour" 0
group_VoronoiNoise_transform 1
VoronoiNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name VoronoiNoise_regular
xpos 1712
ypos 1000
}
set N26724380 [stack 0]
push $N1eaed8a0
Dot {
name Dot7
tile_color 0xd8d8d8ff
note_font_size 20
xpos 1200
ypos 924
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"VoronoiNoise\" iterate pixelWise ef2a93f7ff8030991a3e20393c3fc2723d0df6b7c52d210aa180af4bf056ee20 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], int idArr\[], float value, int id)\n\{\n  float temp;\n  int tempID;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    tempID = idArr\[i];\n    arr\[i] = value;\n    idArr\[i] = id;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n      idArr\[i + 1] = tempID;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel VoronoiNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n    int idArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, idArray, length(input - featurePoint), id);\n            \}\n        \}\n      \}\n    \}\n\n    float3 col = float3(float(idArray\[iRange]) / rand_modulus, 0.0f, 0.0f);\n    lastRandom = lcgRandom(idArray\[iRange]);\n    col.y = float(lastRandom) / rand_modulus;\n    lastRandom = lcgRandom(lastRandom);\n    col.z = float(lastRandom) / rand_modulus;\n\n    for(int component = 0; component < 3; component++)\n      dst(component) = pow( col\[component] * gain, gamma);\n    dst(3) = 1.0f;\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
VoronoiNoise_Range {{parent.range}}
"VoronoiNoise_Dark Colour" 0
group_VoronoiNoise_transform 1
VoronoiNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name VoronoiNoise3
xpos 1172
ypos 1037
}
set N267488d0 [stack 0]
push $N186d37a0
Dot {
name Dot4
tile_color 0xd8d8d8ff
note_font_size 20
xpos 182
ypos 888
}
set N267683b0 [stack 0]
BlinkScript {
KernelDescription "2 \"Worley\" iterate pixelWise 365128efa0ac14d4003f1fbe71b86d1dc60095777185488b8adb0c7aeb2b00e7 2 \"src\" Read Point \"dst\" Write Point 6 \"Invert\" Bool 1 AA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"invert\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 2 \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n\n// Blink Kernel\nkernel Worley : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    bool invert;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", false);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float distance = 6666.0f;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              distance = min(distance, dot(input - featurePoint, input - featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    distance = sqrt(distance);\n    if (invert)\n      distance = 1.0f - distance;\n    distance = pow( distance * gain, gamma );\n    dst() = getColour(distance);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
"Worley_Dark Colour" 0
group_Worley_transform 1
Worley_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name WorleyNoise_regular3
xpos 431
ypos 989
}
set N2676cd50 [stack 0]
push $N200237d0
Dot {
name Dot2
tile_color 0xd8d8d8ff
note_font_size 20
xpos -427
ypos 883
}
set N2678a5d0 [stack 0]
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"Worley\" iterate pixelWise 3017dbac59db3aa8a690859f035a39ccccc90e28a42a2a85acfd1df824277203 2 \"src\" Read Point \"dst\" Write Point 6 \"Invert\" Bool 1 AA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"invert\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 2 \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n\n// Blink Kernel\nkernel Worley : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    bool invert;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", false);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float distance = 6666.0f;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              distance = min(distance, length(input - featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    if (invert)\n      distance = 1.0f - distance;\n    distance = pow( distance * gain, gamma );\n    dst() = getColour(distance);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
"Worley_Dark Colour" 0
group_Worley_transform 1
Worley_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name WorleyNoise
label red
xpos -150
ypos 978
}
set N2678ee20 [stack 0]
push $N249599b0
Dot {
name Dot1
tile_color 0xd8d8d8ff
note_font_size 20
xpos -870
ypos 789
}
set N2679faf0 [stack 0]
Expression {
temp_name0 gain
temp_expr0 ga
temp_name1 octaves
temp_expr1 oc
temp_name2 lun
temp_expr2 lu
expr0 fBm(r,g,b,octaves,lun,gain)
channel1 none
channel2 none
channel3 none
name Expression5
label "lun oct gain\nfBm"
xpos -809
ypos 864
}
Grade {
blackpoint -0.7
black_clamp false
name Grade29
xpos -809
ypos 930
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
push $N2679faf0
Expression {
temp_name0 gain
temp_expr0 ga
temp_name1 octaves
temp_expr1 oc
temp_name2 lun
temp_expr2 lu
expr0 turbulence(r,g,b,octaves,lun,gain)
channel1 none
channel2 none
channel3 none
name Expression1
label "lun oct gain\nturbulence"
xpos -1165
ypos 893
}
Switch {
inputs 12
which {{type}}
name Switch2
xpos -1034
ypos 1778
}
Shuffle {
green red
blue red
alpha red
name Shuffle1
tile_color 0xb52021ff
label red
xpos -1034
ypos 1823
}
push $N2492ae10
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 2222
black_clamp false
name Grade26
xpos 5205
ypos 1128
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ChebyshevNoise\" iterate pixelWise 9b7bb5baffea01f2815b43ed568bc5cc70ddd62141c742f57b3cc33855f38778 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ChebyshevNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ChebyshevDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ChebyshevNoise_Range {{parent.range}}
"ChebyshevNoise_Dark Colour" 0
ChebyshevNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ChebyShevNoise_regular3
xpos 5205
ypos 1154
}
push $N2492ae10
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add -1111
black_clamp false
name Grade27
xpos 5302
ypos 1056
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ChebyshevNoise\" iterate pixelWise 9b7bb5baffea01f2815b43ed568bc5cc70ddd62141c742f57b3cc33855f38778 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ChebyshevNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ChebyshevDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ChebyshevNoise_Range {{parent.range}}
"ChebyshevNoise_Dark Colour" 0
ChebyshevNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ChebyShevNoise_regular2
xpos 5302
ypos 1082
}
push $N2492ae10
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 1111
black_clamp false
name Grade28
xpos 5402
ypos 996
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ChebyshevNoise\" iterate pixelWise 9b7bb5baffea01f2815b43ed568bc5cc70ddd62141c742f57b3cc33855f38778 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ChebyshevNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ChebyshevDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ChebyshevNoise_Range {{parent.range}}
"ChebyshevNoise_Dark Colour" 0
ChebyshevNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ChebyShevNoise_regular1
xpos 5402
ypos 1022
}
push $N200095f0
Remove {
inputs 0
name Remove8
autolabel "str(nuke.thisNode()\['operation'].value())+' ' + str(nuke.thisNode()\['channels'].value())+('+' if nuke.thisNode()\['channels2'].value()!='none' else '')+('\\n'+nuke.thisNode()\['label'].value() if nuke.thisNode()\['label'].value() else ' ')"
xpos 5592
ypos 858
hide_input true
}
Copy {
inputs 2
from0 rgba.red
to0 rgba.red
name Copy29
xpos 5592
ypos 967
disable {{!parent.red}}
}
Copy {
inputs 2
from0 rgba.green
to0 rgba.green
name Copy30
xpos 5592
ypos 1032
disable {{!parent.green}}
}
Copy {
inputs 2
from0 rgba.blue
to0 rgba.blue
name Copy31
xpos 5592
ypos 1095
disable {{!parent.blue}}
}
Copy {
inputs 2
from0 rgba.alpha
to0 rgba.alpha
name Copy32
xpos 5592
ypos 1154
disable {{!parent.blue}}
}
Dot {
name Dot29
tile_color 0xd8d8d8ff
note_font_size 20
xpos 5620
ypos 1638
}
push $N2666a170
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 2222
black_clamp false
name Grade23
xpos 4586
ypos 1134
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ChebyshevNoise\" iterate pixelWise 85a52ef4d1a8167ec6dc1283c729ab1cebc7895c1963da297b84e031adebfc77 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ChebyshevNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ChebyshevDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ChebyshevNoise_Range {{parent.range}}
"ChebyshevNoise_Dark Colour" 0
ChebyshevNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ChebyShevNoise3
xpos 4586
ypos 1160
}
push $N2666a170
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add -1111
black_clamp false
name Grade24
xpos 4681
ypos 1059
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ChebyshevNoise\" iterate pixelWise 85a52ef4d1a8167ec6dc1283c729ab1cebc7895c1963da297b84e031adebfc77 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ChebyshevNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ChebyshevDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ChebyshevNoise_Range {{parent.range}}
"ChebyshevNoise_Dark Colour" 0
ChebyshevNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ChebyShevNoise2
xpos 4681
ypos 1085
}
push $N2666a170
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 1111
black_clamp false
name Grade25
xpos 4783
ypos 1002
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ChebyshevNoise\" iterate pixelWise 85a52ef4d1a8167ec6dc1283c729ab1cebc7895c1963da297b84e031adebfc77 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ChebyshevNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ChebyshevDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ChebyshevNoise_Range {{parent.range}}
"ChebyshevNoise_Dark Colour" 0
ChebyshevNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ChebyShevNoise1
xpos 4783
ypos 1028
}
push $N2666ed40
push $N1bd85310
Remove {
name Remove7
autolabel "str(nuke.thisNode()\['operation'].value())+' ' + str(nuke.thisNode()\['channels'].value())+('+' if nuke.thisNode()\['channels2'].value()!='none' else '')+('\\n'+nuke.thisNode()\['label'].value() if nuke.thisNode()\['label'].value() else ' ')"
xpos 4973
ypos 864
hide_input true
}
Copy {
inputs 2
from0 rgba.red
to0 rgba.red
name Copy25
xpos 4973
ypos 973
disable {{!parent.red}}
}
Copy {
inputs 2
from0 rgba.green
to0 rgba.green
name Copy26
xpos 4973
ypos 1038
disable {{!parent.green}}
}
Copy {
inputs 2
from0 rgba.blue
to0 rgba.blue
name Copy27
xpos 4973
ypos 1101
disable {{!parent.blue}}
}
Copy {
inputs 2
from0 rgba.alpha
to0 rgba.alpha
name Copy28
xpos 4973
ypos 1159
disable {{!parent.blue}}
}
Dot {
name Dot28
tile_color 0xd8d8d8ff
note_font_size 20
xpos 5001
ypos 1517
}
push $N2668e7d0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 2222
black_clamp false
name Grade20
xpos 3929
ypos 1144
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"EuclidianNoise\" iterate pixelWise c55ec03f12f9faefbc24529f012b5eb5c846a72925b427780cae8ed378c3d24d 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel EuclidianNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, EuclidianDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
EuclidianNoise_Range {{parent.range}}
"EuclidianNoise_Dark Colour" 0
group_EuclidianNoise_transform 1
EuclidianNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name EuclidianNoise_regular3
xpos 3929
ypos 1170
}
push $N2668e7d0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add -1111
black_clamp false
name Grade21
xpos 4026
ypos 1067
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"EuclidianNoise\" iterate pixelWise c55ec03f12f9faefbc24529f012b5eb5c846a72925b427780cae8ed378c3d24d 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel EuclidianNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, EuclidianDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
EuclidianNoise_Range {{parent.range}}
"EuclidianNoise_Dark Colour" 0
group_EuclidianNoise_transform 1
EuclidianNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name EuclidianNoise_regular2
xpos 4026
ypos 1093
}
push $N2668e7d0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 1111
black_clamp false
name Grade22
xpos 4126
ypos 1009
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"EuclidianNoise\" iterate pixelWise c55ec03f12f9faefbc24529f012b5eb5c846a72925b427780cae8ed378c3d24d 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel EuclidianNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, EuclidianDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
EuclidianNoise_Range {{parent.range}}
"EuclidianNoise_Dark Colour" 0
group_EuclidianNoise_transform 1
EuclidianNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name EuclidianNoise_regular1
xpos 4126
ypos 1035
}
push $N26693200
push $N1bd85310
Remove {
name Remove6
autolabel "str(nuke.thisNode()\['operation'].value())+' ' + str(nuke.thisNode()\['channels'].value())+('+' if nuke.thisNode()\['channels2'].value()!='none' else '')+('\\n'+nuke.thisNode()\['label'].value() if nuke.thisNode()\['label'].value() else ' ')"
xpos 4316
ypos 875
hide_input true
}
Copy {
inputs 2
from0 rgba.red
to0 rgba.red
name Copy21
xpos 4316
ypos 981
disable {{!parent.red}}
}
Copy {
inputs 2
from0 rgba.green
to0 rgba.green
name Copy22
xpos 4316
ypos 1046
disable {{!parent.green}}
}
Copy {
inputs 2
from0 rgba.blue
to0 rgba.blue
name Copy23
xpos 4316
ypos 1109
disable {{!parent.blue}}
}
Copy {
inputs 2
from0 rgba.alpha
to0 rgba.alpha
name Copy24
xpos 4316
ypos 1182
disable {{!parent.blue}}
}
Dot {
name Dot23
tile_color 0xd8d8d8ff
note_font_size 20
xpos 4344
ypos 1502
}
push $N266b2bb0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 2222
black_clamp false
name Grade17
xpos 3322
ypos 1145
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"EuclidianNoise\" iterate pixelWise 1414320004d60e120c3e4be78e8c70f632ef4ec8610d7c7bfa0059d00c22cb3b 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel EuclidianNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, EuclidianDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
EuclidianNoise_Range {{parent.range}}
"EuclidianNoise_Dark Colour" 0
EuclidianNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name EuclidianNoise3
xpos 3322
ypos 1171
}
push $N266b2bb0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add -1111
black_clamp false
name Grade18
xpos 3419
ypos 1070
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"EuclidianNoise\" iterate pixelWise 1414320004d60e120c3e4be78e8c70f632ef4ec8610d7c7bfa0059d00c22cb3b 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel EuclidianNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, EuclidianDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
EuclidianNoise_Range {{parent.range}}
"EuclidianNoise_Dark Colour" 0
EuclidianNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name EuclidianNoise2
xpos 3419
ypos 1096
}
push $N266b2bb0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 1111
black_clamp false
name Grade19
xpos 3520
ypos 1010
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"EuclidianNoise\" iterate pixelWise 1414320004d60e120c3e4be78e8c70f632ef4ec8610d7c7bfa0059d00c22cb3b 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel EuclidianNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, EuclidianDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
EuclidianNoise_Range {{parent.range}}
"EuclidianNoise_Dark Colour" 0
EuclidianNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name EuclidianNoise1
xpos 3520
ypos 1036
}
push $N266b7670
push $N1bd85310
Remove {
name Remove5
autolabel "str(nuke.thisNode()\['operation'].value())+' ' + str(nuke.thisNode()\['channels'].value())+('+' if nuke.thisNode()\['channels2'].value()!='none' else '')+('\\n'+nuke.thisNode()\['label'].value() if nuke.thisNode()\['label'].value() else ' ')"
xpos 3709
ypos 875
hide_input true
}
Copy {
inputs 2
from0 rgba.red
to0 rgba.red
name Copy17
xpos 3709
ypos 983
disable {{!parent.red}}
}
Copy {
inputs 2
from0 rgba.green
to0 rgba.green
name Copy18
xpos 3709
ypos 1048
disable {{!parent.green}}
}
Copy {
inputs 2
from0 rgba.blue
to0 rgba.blue
name Copy19
xpos 3709
ypos 1111
disable {{!parent.blue}}
}
Copy {
inputs 2
from0 rgba.alpha
to0 rgba.alpha
name Copy20
xpos 3709
ypos 1186
disable {{!parent.blue}}
}
Dot {
name Dot20
tile_color 0xd8d8d8ff
note_font_size 20
xpos 3737
ypos 1527
}
push $N266d6f60
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 2222
black_clamp false
name Grade14
xpos 2738
ypos 1160
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ManhattanNoise\" iterate pixelWise 481093b9fb1fdf55fde93ad91bb68b66d5e638e3c90db7d2cb795eb4769cedbb 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ManhattanNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ManhattanDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ManhattanNoise_Range {{parent.range}}
"ManhattanNoise_Dark Colour" 0
group_ManhattanNoise_transform 1
ManhattanNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ManhattanNoise_regular3
xpos 2738
ypos 1186
}
push $N266d6f60
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add -1111
black_clamp false
name Grade15
xpos 2836
ypos 1086
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ManhattanNoise\" iterate pixelWise 481093b9fb1fdf55fde93ad91bb68b66d5e638e3c90db7d2cb795eb4769cedbb 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ManhattanNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ManhattanDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ManhattanNoise_Range {{parent.range}}
"ManhattanNoise_Dark Colour" 0
group_ManhattanNoise_transform 1
ManhattanNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ManhattanNoise_regular2
xpos 2836
ypos 1112
}
push $N266d6f60
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 1111
black_clamp false
name Grade16
xpos 2936
ypos 1024
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ManhattanNoise\" iterate pixelWise 481093b9fb1fdf55fde93ad91bb68b66d5e638e3c90db7d2cb795eb4769cedbb 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ManhattanNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ManhattanDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ManhattanNoise_Range {{parent.range}}
"ManhattanNoise_Dark Colour" 0
group_ManhattanNoise_transform 1
ManhattanNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ManhattanNoise_regular1
xpos 2936
ypos 1050
}
push $N266dbb80
push $N1bd85310
Remove {
name Remove4
autolabel "str(nuke.thisNode()\['operation'].value())+' ' + str(nuke.thisNode()\['channels'].value())+('+' if nuke.thisNode()\['channels2'].value()!='none' else '')+('\\n'+nuke.thisNode()\['label'].value() if nuke.thisNode()\['label'].value() else ' ')"
xpos 3125
ypos 896
hide_input true
}
Copy {
inputs 2
from0 rgba.red
to0 rgba.red
name Copy13
xpos 3125
ypos 1000
disable {{!parent.red}}
}
Copy {
inputs 2
from0 rgba.green
to0 rgba.green
name Copy14
xpos 3125
ypos 1065
disable {{!parent.green}}
}
Copy {
inputs 2
from0 rgba.blue
to0 rgba.blue
name Copy15
xpos 3125
ypos 1128
disable {{!parent.blue}}
}
Copy {
inputs 2
from0 rgba.alpha
to0 rgba.alpha
name Copy16
xpos 3125
ypos 1201
disable {{!parent.blue}}
}
Dot {
name Dot17
tile_color 0xd8d8d8ff
note_font_size 20
xpos 3153
ypos 1523
}
push $N266fb610
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 2222
black_clamp false
name Grade11
xpos 2138
ypos 1155
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ManhattanNoise\" iterate pixelWise 49f23d9559c77c47334f4a66696975b65295024e1667d6c7704aa4fe9a12efb2 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ManhattanNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ManhattanDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ManhattanNoise_Range {{parent.range}}
"ManhattanNoise_Dark Colour" 0
group_ManhattanNoise_transform 1
ManhattanNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ManhattanNoise3
xpos 2138
ypos 1181
}
push $N266fb610
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add -1111
black_clamp false
name Grade12
xpos 2237
ypos 1083
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ManhattanNoise\" iterate pixelWise 49f23d9559c77c47334f4a66696975b65295024e1667d6c7704aa4fe9a12efb2 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ManhattanNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ManhattanDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ManhattanNoise_Range {{parent.range}}
"ManhattanNoise_Dark Colour" 0
group_ManhattanNoise_transform 1
ManhattanNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ManhattanNoise2
xpos 2237
ypos 1109
}
push $N266fb610
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 1111
black_clamp false
name Grade13
xpos 2337
ypos 1020
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"ManhattanNoise\" iterate pixelWise 49f23d9559c77c47334f4a66696975b65295024e1667d6c7704aa4fe9a12efb2 2 \"src\" Read Point \"dst\" Write Point 6 \"Range\" Float 1 AABAQA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"range\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 4 \"fRange\" Float 1 1 AAAAAA== \"iRange\" Int 1 1 AAAAAA== \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n# define MAX_DISTANCE_ARRAY 12\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Function\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\n// Insertion Array\nstatic void insert(float arr\[], float value)\n\{\n  float temp;\n  for (int i = MAX_DISTANCE_ARRAY - 1; i >= 0; i--)\n  \{\n    if (value > arr\[i])\n      break;\n    temp = arr\[i];\n    arr\[i] = value;\n    if (i + 1 < MAX_DISTANCE_ARRAY)\n    \{\n      arr\[i + 1] = temp;\n    \}\n  \}\n\}\n\n\n// Blink Kernel\nkernel ManhattanNoise : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    float range;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float fRange;\n    int iRange;\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(range, \"Range\", 3.0f);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    fRange = clamp(range, 0.0f, float(MAX_DISTANCE_ARRAY - 2));\n    iRange = int(fRange);\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float distanceArray\[MAX_DISTANCE_ARRAY];\n\n    // Initialize values in distance array to large values\n    for (int i = 0; i < MAX_DISTANCE_ARRAY; i++)\n        distanceArray\[i] = 6666;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              insert(distanceArray, ManhattanDistanceFunc(input, featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    float color = (distanceArray\[ iRange + 2 ] - distanceArray\[ iRange + 1 ]) * fmod(fRange, 1.0f) + distanceArray\[ iRange + 1] - distanceArray\[0];\n    color = pow( color * gain, gamma );\n    dst() = getColour(color);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
ManhattanNoise_Range {{parent.range}}
"ManhattanNoise_Dark Colour" 0
group_ManhattanNoise_transform 1
ManhattanNoise_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name ManhattanNoise1
xpos 2337
ypos 1046
}
push $N266fff30
push $N1bd85310
Remove {
name Remove3
autolabel "str(nuke.thisNode()\['operation'].value())+' ' + str(nuke.thisNode()\['channels'].value())+('+' if nuke.thisNode()\['channels2'].value()!='none' else '')+('\\n'+nuke.thisNode()\['label'].value() if nuke.thisNode()\['label'].value() else ' ')"
xpos 2525
ypos 891
hide_input true
}
Copy {
inputs 2
from0 rgba.red
to0 rgba.red
name Copy9
xpos 2525
ypos 997
disable {{!parent.red}}
}
Copy {
inputs 2
from0 rgba.green
to0 rgba.green
name Copy10
xpos 2525
ypos 1062
disable {{!parent.green}}
}
Copy {
inputs 2
from0 rgba.blue
to0 rgba.blue
name Copy11
xpos 2525
ypos 1125
disable {{!parent.blue}}
}
Copy {
inputs 2
from0 rgba.alpha
to0 rgba.alpha
name Copy12
xpos 2525
ypos 1199
disable {{!parent.blue}}
}
Dot {
name Dot15
tile_color 0xd8d8d8ff
note_font_size 20
xpos 2553
ypos 1512
}
push $N26724380
Dot {
name Dot11
tile_color 0xd8d8d8ff
note_font_size 20
xpos 1740
ypos 1506
}
push $N267488d0
Dot {
name Dot10
tile_color 0xd8d8d8ff
note_font_size 20
xpos 1200
ypos 1497
}
push $N267683b0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 2222
black_clamp false
name Grade8
xpos 154
ypos 1146
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
KernelDescription "2 \"Worley\" iterate pixelWise 365128efa0ac14d4003f1fbe71b86d1dc60095777185488b8adb0c7aeb2b00e7 2 \"src\" Read Point \"dst\" Write Point 6 \"Invert\" Bool 1 AA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"invert\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 2 \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n\n// Blink Kernel\nkernel Worley : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    bool invert;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", false);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float distance = 6666.0f;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              distance = min(distance, dot(input - featurePoint, input - featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    distance = sqrt(distance);\n    if (invert)\n      distance = 1.0f - distance;\n    distance = pow( distance * gain, gamma );\n    dst() = getColour(distance);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
"Worley_Dark Colour" 0
group_Worley_transform 1
Worley_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name WorleyNoise_regular1
xpos 154
ypos 1172
}
push $N267683b0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add -1111
black_clamp false
name Grade9
xpos 256
ypos 1073
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
KernelDescription "2 \"Worley\" iterate pixelWise 365128efa0ac14d4003f1fbe71b86d1dc60095777185488b8adb0c7aeb2b00e7 2 \"src\" Read Point \"dst\" Write Point 6 \"Invert\" Bool 1 AA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"invert\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 2 \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n\n// Blink Kernel\nkernel Worley : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    bool invert;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", false);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float distance = 6666.0f;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              distance = min(distance, dot(input - featurePoint, input - featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    distance = sqrt(distance);\n    if (invert)\n      distance = 1.0f - distance;\n    distance = pow( distance * gain, gamma );\n    dst() = getColour(distance);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
"Worley_Dark Colour" 0
group_Worley_transform 1
Worley_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name WorleyNoise_regular2
xpos 256
ypos 1099
}
push $N267683b0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 1111
black_clamp false
name Grade10
xpos 355
ypos 1012
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
KernelDescription "2 \"Worley\" iterate pixelWise 365128efa0ac14d4003f1fbe71b86d1dc60095777185488b8adb0c7aeb2b00e7 2 \"src\" Read Point \"dst\" Write Point 6 \"Invert\" Bool 1 AA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"invert\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 2 \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n\n// Blink Kernel\nkernel Worley : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    bool invert;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", false);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, numberFeaturePoints;\n    float distance = 6666.0f;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            lastRandom = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(lastRandom);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              distance = min(distance, dot(input - featurePoint, input - featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    distance = sqrt(distance);\n    if (invert)\n      distance = 1.0f - distance;\n    distance = pow( distance * gain, gamma );\n    dst() = getColour(distance);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
"Worley_Dark Colour" 0
group_Worley_transform 1
Worley_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name WorleyNoise_regular4
xpos 355
ypos 1038
}
push $N2676cd50
push $N1bd85310
Remove {
name Remove2
autolabel "str(nuke.thisNode()\['operation'].value())+' ' + str(nuke.thisNode()\['channels'].value())+('+' if nuke.thisNode()\['channels2'].value()!='none' else '')+('\\n'+nuke.thisNode()\['label'].value() if nuke.thisNode()\['label'].value() else ' ')"
xpos 592
ypos 883
hide_input true
}
Copy {
inputs 2
from0 rgba.red
to0 rgba.red
name Copy5
xpos 592
ypos 989
disable {{!parent.red}}
}
Copy {
inputs 2
from0 rgba.green
to0 rgba.green
name Copy6
xpos 592
ypos 1054
disable {{!parent.green}}
}
Copy {
inputs 2
from0 rgba.blue
to0 rgba.blue
name Copy7
xpos 592
ypos 1117
disable {{!parent.blue}}
}
Copy {
inputs 2
from0 rgba.alpha
to0 rgba.alpha
name Copy8
xpos 592
ypos 1191
disable {{!parent.blue}}
}
push $N2678a5d0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 2222
black_clamp false
name Grade7
xpos -455
ypos 1142
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"Worley\" iterate pixelWise 3017dbac59db3aa8a690859f035a39ccccc90e28a42a2a85acfd1df824277203 2 \"src\" Read Point \"dst\" Write Point 6 \"Invert\" Bool 1 AA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"invert\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 2 \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n\n// Blink Kernel\nkernel Worley : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    bool invert;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", false);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float distance = 6666.0f;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              distance = min(distance, length(input - featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    if (invert)\n      distance = 1.0f - distance;\n    distance = pow( distance * gain, gamma );\n    dst() = getColour(distance);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
"Worley_Dark Colour" 0
group_Worley_transform 1
Worley_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name WorleyNoise3
label alpha
xpos -455
ypos 1180
}
push $N2678a5d0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add -1111
black_clamp false
name Grade6
xpos -353
ypos 1068
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"Worley\" iterate pixelWise 3017dbac59db3aa8a690859f035a39ccccc90e28a42a2a85acfd1df824277203 2 \"src\" Read Point \"dst\" Write Point 6 \"Invert\" Bool 1 AA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"invert\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 2 \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n\n// Blink Kernel\nkernel Worley : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    bool invert;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", false);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float distance = 6666.0f;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              distance = min(distance, length(input - featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    if (invert)\n      distance = 1.0f - distance;\n    distance = pow( distance * gain, gamma );\n    dst() = getColour(distance);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
"Worley_Dark Colour" 0
group_Worley_transform 1
Worley_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name WorleyNoise2
label blue
xpos -353
ypos 1106
}
push $N2678a5d0
Grade {
channels {rgba.red -rgba.green -rgba.blue none}
add 1111
black_clamp false
name Grade5
xpos -252
ypos 1005
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
BlinkScript {
ProgramGroup 1
KernelDescription "2 \"Worley\" iterate pixelWise 3017dbac59db3aa8a690859f035a39ccccc90e28a42a2a85acfd1df824277203 2 \"src\" Read Point \"dst\" Write Point 6 \"Invert\" Bool 1 AA== \"Gain\" Float 1 AACAPw== \"Gamma\" Float 1 AACAPw== \"Dark Colour\" Float 4 AAAAAAAAAAAAAAAAAACAPw== \"Light Colour\" Float 4 AACAPwAAgD8AAIA/AACAPw== \"transform\" Float 16 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== 6 \"invert\" 1 1 \"gain\" 1 1 \"gamma\" 1 1 \"dark_col\" 4 1 \"light_col\" 4 1 \"transform\" 16 1 2 \"transform_inv\" Float 16 1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA== \"z\" Float 1 1 AAAAAA=="
kernelSource "// https://aftbit.com/cell-noise-2/\n\n// C++11\nconst uint rand_multiplier = 48271;\nconst uint rand_increment  = 0;\nconst uint rand_modulus    = 2147483647;\n\nstatic int lcgRandom(int seed)\n\{\n  return abs((seed * rand_multiplier + rand_increment) % rand_modulus);\n\}\n\n// FNV Hash\nconst uint OFFSET_BASIS = 2166136261;\nconst uint FNV_PRIME = 16777619;\n\nstatic uint hash(uint i, uint j, uint k)\n\{\n  return ((((((OFFSET_BASIS ^ i) * FNV_PRIME) ^ j) * FNV_PRIME) ^ k) * FNV_PRIME);\n\}\n\n// Poisson Distribution\nconst uint one   =  393325350;\nconst uint two   = 1022645910;\nconst uint three = 1861739990;\nconst uint four  = 2700834071;\nconst uint five  = 3372109335;\nconst uint six   = 3819626178;\nconst uint seven = 4075350088;\nconst uint eight = 4203212043;\n\nstatic uint probLookup(uint value)\n\{\n  if (value < one) return 1;\n  if (value < two) return 2;\n  if (value < three) return 3;\n  if (value < four) return 4;\n  if (value < five) return 5;\n  if (value < six) return 6;\n  if (value < seven) return 7;\n  if (value < eight) return 8;\n  return 9;\n\}\n\n// Distance Functions\nstatic float EuclidianDistanceFunc(float3 p1, float3 p2)\n\{\n  return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y) + (p1.z - p2.z) * (p1.z - p2.z);\n\}\n\nstatic float ManhattanDistanceFunc(float3 p1, float3 p2)\n\{\n  return fabs(p1.x - p2.x) + fabs(p1.y - p2.y) + fabs(p1.z - p2.z);\n\}\n\nstatic float ChebyshevDistanceFunc(float3 p1, float3 p2)\n\{\n  float3 diff = p1 - p2;\n  return max(max(fabs(diff.x), fabs(diff.y)), fabs(diff.z));\n\}\n\n\n// Blink Kernel\nkernel Worley : ImageComputationKernel<ePixelWise>\n\{\n  Image<eRead, eAccessPoint, eEdgeClamped> src;\n  Image<eWrite> dst;\n\n  param:\n    bool invert;\n    float gain;\n    float gamma;\n    float4 dark_col;\n    float4 light_col;\n    float4x4 transform;\n\n  local:\n    float4x4 transform_inv;\n    float z;\n\n  void define()\n  \{\n    defineParam(invert, \"Invert\", false);\n    defineParam(gain, \"Gain\", 1.0f);\n    defineParam(gamma, \"Gamma\", 1.0f);\n    defineParam(dark_col, \"Dark Colour\", float4(0.0f, 0.0f, 0.0f, 1.0f));\n    defineParam(light_col, \"Light Colour\", float4(1.0f, 1.0f, 1.0f, 1.0f));\n  \}\n\n  void init()\n  \{\n    transform_inv = transform.invert();\n    z = transform_inv\[2]\[3];\n  \}\n\n  static float3 multVectMatrix(float3 vec, float4x4 M)\n  \{\n    float3 out = float3(\n      vec.x * M\[0]\[0] + vec.y * M\[0]\[1] + vec.z * M\[0]\[2] + M\[0]\[3],\n      vec.x * M\[1]\[0] + vec.y * M\[1]\[1] + vec.z * M\[1]\[2] + M\[1]\[3],\n      vec.x * M\[2]\[0] + vec.y * M\[2]\[1] + vec.z * M\[2]\[2] + M\[2]\[3]\n    );\n\n    return out;\n  \}\n\n  float4 getColour(float a) \{\n    return dark_col * clamp(1 - a, 0.0f, 1.0f) + light_col * a;\n  \}\n\n  void process(int2 pos)\n  \{\n\n    //Declare some values for later use\n    int lastRandom, id, numberFeaturePoints;\n    float distance = 6666.0f;\n    float3 randomDiff, featurePoint;\n    int cubeX, cubeY, cubeZ;\n\n    float4 srcval = src();\n    float3 input = float3(srcval.x, srcval.y, srcval.z+z);\n    input = multVectMatrix(input, transform_inv);\n\n    // Determine which cube the evaluation point is in\n    int evalCubeX = floor(input.x);\n    int evalCubeY = floor(input.y);\n    int evalCubeZ = floor(input.z);\n\n    for (int i = -1; i < 2; ++i)\n    \{\n      for (int j = -1; j < 2; ++j)\n      \{\n        for (int k = -1; k < 2; ++k)\n        \{\n            cubeX = evalCubeX + i;\n            cubeY = evalCubeY + j;\n            cubeZ = evalCubeZ + k;\n\n            // Generate a reproducible random number generator for the cube\n            id = lcgRandom(hash(cubeX, cubeY, cubeZ));\n            // Determine how many feature points are in the cube\n            numberFeaturePoints = probLookup(id);\n            // Check each feature point\n            for (uint l = 0; l < numberFeaturePoints; ++l)\n            \{\n              lastRandom = lcgRandom(id);\n              randomDiff.x = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.y = float(lastRandom) / rand_modulus;\n\n              lastRandom = lcgRandom(lastRandom);\n              randomDiff.z = float(lastRandom) / rand_modulus;\n\n              featurePoint = float3(randomDiff.x + float(cubeX), randomDiff.y + float(cubeY), randomDiff.z + float(cubeZ));\n\n              distance = min(distance, length(input - featurePoint));\n            \}\n        \}\n      \}\n    \}\n\n    if (invert)\n      distance = 1.0f - distance;\n    distance = pow( distance * gain, gamma );\n    dst() = getColour(distance);\n\n  \}\n\n\};"
useGPUIfAvailable {{parent.gpu}}
rebuild ""
"Worley_Dark Colour" 0
group_Worley_transform 1
Worley_transform {
    {1 0 0 0}
    {0 1 0 0}
    {0 0 1 0}
    {0 0 0 1}
  }
rebuild_finalise ""
name WorleyNoise1
label green
xpos -252
ypos 1043
}
push $N2678ee20
push $N1bd85310
Remove {
name Remove1
autolabel "str(nuke.thisNode()\['operation'].value())+' ' + str(nuke.thisNode()\['channels'].value())+('+' if nuke.thisNode()\['channels2'].value()!='none' else '')+('\\n'+nuke.thisNode()\['label'].value() if nuke.thisNode()\['label'].value() else ' ')"
xpos -17
ypos 882
hide_input true
}
Copy {
inputs 2
from0 rgba.red
to0 rgba.red
name Copy3
xpos -17
ypos 984
disable {{!parent.red}}
}
Copy {
inputs 2
from0 rgba.green
to0 rgba.green
name Copy1
xpos -17
ypos 1049
disable {{!parent.green}}
}
Copy {
inputs 2
from0 rgba.blue
to0 rgba.blue
name Copy2
xpos -17
ypos 1112
disable {{!parent.blue}}
}
Copy {
inputs 2
from0 rgba.alpha
to0 rgba.alpha
name Copy4
xpos -17
ypos 1186
disable {{!parent.blue}}
}
push $N2679faf0
Expression {
temp_name0 gain
temp_expr0 ga
temp_name1 octaves
temp_expr1 oc
temp_name2 lun
temp_expr2 lu
expr0 "parent.red == 1 ? fBm(r,g,b,octaves,lun,gain) : 0"
expr1 "parent.green == 1 ? fBm(r+1111,g,b,octaves,lun,gain) : 0"
expr2 "parent.blue == 1 ? fBm(r-1111,g,b,octaves,lun,gain) : 0"
channel3 alpha
expr3 "parent.alpha == 1 ? fBm(r+2222,g,b,octaves,lun,gain) : 0"
name Expression3
label "lun oct gain\nfBm"
xpos -717
ypos 857
}
Grade {
blackpoint -0.7
black_clamp false
name Grade2
xpos -717
ypos 920
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
push $N2679faf0
Expression {
temp_name0 gain
temp_expr0 ga
temp_name1 octaves
temp_expr1 oc
temp_name2 lun
temp_expr2 lu
expr0 "parent.red == 1 ? turbulence(r,g,b,octaves,lun,gain) : 0"
expr1 "parent.green == 1 ? turbulence(r+1111,g,b,octaves,lun,gain) : 0"
expr2 "parent.blue == 1 ? turbulence(r-1111,g,b,octaves,lun,gain) : 0"
channel3 alpha
expr3 "parent.alpha == 1 ? turbulence(r+2222,g,b,octaves,lun,gain) : 0"
name Expression2
label "lun oct gain\nturbulence"
xpos -1013
ypos 875
}
Switch {
inputs 12
which {{type}}
name Switch1
xpos -844
ypos 1723
}
Switch {
inputs 2
which {{parent.mono}}
name Switch3
label "mono or rgba"
xpos -844
ypos 1912
}
Expression {
expr0 abs(r)
expr1 abs(g)
expr2 abs(b)
channel3 {none none none -rgba.alpha}
name Expression4
note_font Helvetica
xpos -844
ypos 1960
disable {{!parent.absolute}}
}
Clamp {
channels rgba
name Clamp1
xpos -844
ypos 1986
disable {{!parent.clamp}}
}
Invert {
channels rgba
name Invert1
xpos -844
ypos 2012
disable {{!parent.invert}}
}
Grade {
black_clamp false
name Grade_post
selected true
xpos -844
ypos 2102
addUserKnob {20 User}
addUserKnob {22 "keep luma" -STARTLINE T keepLuma()}
}
Merge2 {
inputs 2
operation mask
bbox A
name Merge12
xpos -844
ypos 2202
disable {{!parent.unpremult}}
}
set N26f0d3d0 [stack 0]
Copy {
inputs 2
from0 rgba.alpha
to0 rgba.alpha
name Copy33
xpos -844
ypos 2258
disable {{!parent.keepAlpha}}
}
Output {
name Output1
xpos -844
ypos 2380
}
push $N26f0d3d0
Viewer {
frame 1025
frame_range 1001-1063
viewerProcess "None (default)"
name Viewer1
xpos -586
ypos 2098
}
end_group
