set cut_paste_input [stack 0]
version 9.0 v7
push 0
push 0
push 0
push $cut_paste_input
add_layer {N N.red N.green N.blue N.alpha N.x N.y N.z N.r N.g N.b}
Group {
 inputs 4
 name CamProj_WorldPos
 help "This gizmo does camera projection using the STMap node to remap all the layers in the input image.  It uses a 3D render of point positions in world space (as output by Nuke's ScanlineRender node) and a 3D camera to create UV texture coordinates that are then used to warp an input image such as a matte painting. It optionally uses exr metadata (from a RenderMan-compliant renderer such as PRMan or 3Delight) to work out the 3D camera projection.\n\nNOTE: The projection works best with unmatted input images or at least unpremulted matting with some coverage, then all masking occurs within the gizmo.\n\nIt can mask the projected image in the following ways:\n- Crop based on camera frustum.\n- Input image matte channel.\n- Input alpha from the 3D render.\n- Depth map shadow mask based on an image of point (P) in world space rendered from the  projecting camera.  This means the projection will only be visible based on what surfaces the projecting camera can see.  The effect of this is more evident as the viewing camera changes position and angle.\n- Projecting on surfaces facing camera, using normal (N) in world space. This means all surfaces facing the projecting camera will receive the projection regardless of whether they are blocked by other geometry. This is like Nuke's existing camera projection masking."
 knobChanged "\n        \n\n\n"
 tile_color 0x9effffff
 label "\[value frame]"
 note_font_size 14
 selected true
 xpos 2696
 ypos 22451
 addUserKnob {20 ReProject3D}
 addUserKnob {22 GrabCamera l "Freeze Camera" t "freeze camera on the certain frame" T "n = nuke.thisGroup()\nn.end()\ncam = n.input(3)\nf = nuke.frame()\ns = n\['specificFrame'].value()\n\ntopnode_name = nuke.tcl(\"full_name \[topnode %s]\" % cam.name()) \ncam = nuke.toNode(topnode_name)\nif s == 1:\n    f = n\['frame'].value()\nelse:\n    n\['frame'].setValue(f)\n\t\n\n\ncam\['translate'].setExpression(\"curve(\"+str(f)+\")\")\ncam\['rotate'].setExpression(\"curve(\"+str(f)+\")\")\ncam\['focal'].setExpression(\"curve(\"+str(f)+\")\")" +STARTLINE}
 addUserKnob {6 specificFrame l "specific frame" +STARTLINE}
 addUserKnob {3 frame -STARTLINE}
 frame 1048
 addUserKnob {26 ""}
 addUserKnob {41 surface_point l "surface point" t "Choose the input P surface layer from the \"vec\" input.  Note that it needs to be rendered in world space." T ShuffleP.in}
 addUserKnob {41 surface_alpha l "surface alpha" t "Choose the input surface's alpha channel, from the \"vec\" input.  This is used as an overall object mask to matte the camera projection." T Multiply2.maskChannelMask}
 addUserKnob {41 projected_matte l "projected matte" t "Choose a matte channel in the stream from the \"img\" input to premult all layers of the projected texture.  Note: this happens *after* the texture warp since it's cleaner." T Multiply7.maskChannelMask}
 addUserKnob {4 camera l INVISIBLE t "Choose either a Nuke 3D camera (cam input) or, if available, derive the camera position and projection from RenderMan OpenEXR metadata (vec input)." +INVISIBLE M {"nuke camera" "renderman openexr metadata" "" "" "" "" "" ""}}
 addUserKnob {7 imageAspect l INVISIBLE t "Enter the aspect ratio of the source image being projected." +INVISIBLE R 0 3}
 imageAspect {{input0.width/input0.height}}
 addUserKnob {41 filter T STMap1.filter}
 addUserKnob {6 transformInLog l "transform in log" -STARTLINE}
 addUserKnob {6 outputUVs l "output UV's instead" t "This will output UV (ST) coordinates to the r+g channels.  Use this if you want to remap an image downstream instead of using the internal STMap node." -STARTLINE}
 addUserKnob {20 projection_occlusion l "projection occlusion" n 1}
 projection_occlusion 0
 addUserKnob {6 crop_to_frustum l "crop to cam frustum" t "This will limit the projection to the bounds of the camera frustum, and turn off tiling of the projection edge pixels." +STARTLINE}
 addUserKnob {6 zdepth_shadow l "enable zdepth shadow matte" t "Enables the ability to mask the projection with a shadow which is derived from a still image of world P (point) space as seen from the projecting camera.  This image is connected to the \"shadow\" input.\n\nIf you are projecting on a frame from the rendering camera move then select the right frame, apply a FrameHold and connect to the \"shadow\" input.  If you are projecting from a camera that is not a still frame derived from the render cam move then you need a separate world P (point) space render from the correct point of view." +STARTLINE}
 addUserKnob {6 smooth l "smooth edges" t "Uses Bilateral blur to anti alias the zdepth matte to some extent.  Can be expensive." -STARTLINE}
 addUserKnob {41 shadow_point l "shadow point" t "Choose the input P layer from the \"shadow\" input. It should be a still image in world space and rendered from the projecting camera.\n\nIf using metadata, then the \"shadow\" input can be connected to the main point P render and the frame will be held on the projecting frame.  If _not_using metadata, then you will need to use a FrameHold node before the \"shadow\" input." T ShufflePshad.in}
 addUserKnob {7 bias l "shadow bias" R 0.01 1}
 bias 0.064
 addUserKnob {6 front_facing_only l "project on front facing surfaces only (requires normal vectors)" t "This will mask the projection in the same way Nuke does in full 3D.  Requires world N (normals) in the stream of the \"vec\" input." +STARTLINE}
 addUserKnob {6 smooth_ l "smooth edges" t "Uses Bilateral blur to anti alias the matte to some extent.  Can be expensive." -STARTLINE}
 addUserKnob {41 surface_normal l INVISIBLE t "Choose the normal vectors layer (in world space) from the \"vec\" input. Used to derive the front-facing matte." +INVISIBLE T ShuffleN.in}
 addUserKnob {20 endGroup_1 l endGroup n -1}
 addUserKnob {41 matrix l INVISIBLE +INVISIBLE T Matrix1.matrix}
 addUserKnob {1 focal l INVISIBLE +INVISIBLE}
 focal "\[value parent.\[full_name \[node this]].Shuffle2.focal]"
 addUserKnob {1 filmbackHeight l INVISIBLE +INVISIBLE}
 filmbackHeight "\[value parent.\[full_name \[node this]].Shuffle2.v_apert]"
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 ""}
 addUserKnob {26 q l "" +STARTLINE T "Originally written by Michael Garrett, modified by Alexey Kuchinski"}
}
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x8e8e3800
  label "Cam Shadow UV's"
  note_font_size 18
  xpos 566
  ypos 1149
  bdwidth 344
  bdheight 245
 }
 BackdropNode {
  inputs 0
  name BackdropNode3
  tile_color 0x7171c600
  label "img UV's"
  note_font_size 18
  xpos 557
  ypos 652
  bdwidth 336
  bdheight 244
 }
 BackdropNode {
  inputs 0
  name BackdropNode4
  label "Pworld to Pcam"
  note_font_size 18
  xpos 189
  ypos -68
  bdwidth 190
  bdheight 338
 }
 BackdropNode {
  inputs 0
  name BackdropNode5
  tile_color 0x888888ff
  label "Cam Shadow"
  note_font_size 18
  xpos 292
  ypos 1457
  bdwidth 637
  bdheight 622
 }
 BackdropNode {
  inputs 0
  name Depth5
  label "P to Z from projcam"
  note_font_size 18
  xpos 413
  bdwidth 188
  bdheight 180
 }
 BackdropNode {
  inputs 0
  name Depth6
  label "P to Z from shotcam"
  note_font_size 18
  xpos -43
  ypos -5
  bdwidth 188
  bdheight 180
 }
 BackdropNode {
  inputs 0
  name FacingRatio
  label FacingRatio
  note_font_size 18
  xpos -927
  ypos -155
  bdwidth 294
  bdheight 384
 }
 Input {
  inputs 0
  name vec
  label "\[value number]"
  xpos -720
  ypos -519
 }
 Dot {
  name Dot9
  xpos -686
  ypos -371
 }
set N7e54bb60 [stack 0]
push $N7e54bb60
 Shuffle {
  in rgb
  alpha white
  name ShuffleP
  xpos -606
  ypos -264
 }
 Multiply {
  inputs 1+1
  channels alpha
  value {{"!\[value . maskChannelMask]"}}
  invert_mask true
  name Multiply2
  xpos -606
  ypos -165
  disable {{"!\[exists parent.input0]"}}
 }
set N833938f0 [stack 0]
push $N7e54bb60
 Shuffle {
  in N
  name ShuffleN
  xpos -834
  ypos -257
 }
 ShuffleCopy {
  inputs 2
  name ShuffleCopy2
  label alpha
  xpos -834
  ypos -113
 }
 Unpremult {
  name Unpremult3
  xpos -834
  ypos -75
  disable {{!Multiply2.maskChannelMask i}}
 }
 ColorMatrix {
  matrix {
      {{"\[value \[topnode this.parent.input3].world_matrix.0]"} {"\[value \[topnode this.parent.input3].world_matrix.1]"} {"\[value \[topnode this.parent.input3].world_matrix.2]"}}
      {{"\[value \[topnode this.parent.input3].world_matrix.4]"} {"\[value \[topnode this.parent.input3].world_matrix.5]"} {"\[value \[topnode this.parent.input3].world_matrix.6]"}}
      {{"\[value \[topnode this.parent.input3].world_matrix.8]"} {"\[value \[topnode this.parent.input3].world_matrix.9]"} {"\[value \[topnode this.parent.input3].world_matrix.10]"}}
    }
  invert true
  name ColorMatrix4
  label "Rotate to camera"
  xpos -899
  ypos -30
 }
 Multiply {
  channels {-rgba.red -rgba.green rgba.blue none}
  value -1
  name Multiply10
  label "reverse z"
  xpos -834
  ypos 83
 }
 Expression {
  expr0 clamp(-b)
  expr1 0
  expr2 0
  name Expression5
  xpos -834
  ypos 135
 }
 Expression {
  expr0 "step(0, r)"
  channel1 {-rgba.red -rgba.green -rgba.blue none}
  channel2 {-rgba.red -rgba.green -rgba.blue none}
  channel3 {none none none -rgba.alpha}
  name cull_backfaces
  label step
  xpos -834
  ypos 161
 }
 Bilateral {
  Size 1
  PositionalSigma 2
  ColorSigma 2
  name Bilateral2
  xpos -834
  ypos 2083
  disable {{!smooth_}}
 }
set N7b570380 [stack 0]
 Dot {
  name Dot7
  xpos -800
  ypos 2208
 }
set N7b58ec60 [stack 0]
push $N7b58ec60
push $N7b570380
push $N833938f0
 Dot {
  name Dot14
  xpos -80
  ypos -132
 }
set N7b577b60 [stack 0]
 Dot {
  name Dot15
  xpos -6
  ypos 1804
 }
 Invert {
  channels alpha
  name Invert2
  xpos 590
  ypos 1793
 }
push $N7b577b60
 Dot {
  name Dot16
  xpos 282
  ypos -125
 }
 Unpremult {
  name Unpremult1
  xpos 248
  ypos -49
  disable {{!Multiply2.maskChannelMask i}}
 }
 Expression {
  temp_name0 R
  temp_expr0 "\[value \[topnode this.parent.input3].world_matrix.3]"
  temp_name1 G
  temp_expr1 "\[value \[topnode this.parent.input3].world_matrix.7]"
  temp_name2 B
  temp_expr2 "\[value \[topnode this.parent.input3].world_matrix.11]"
  expr0 r-R
  expr1 g-G
  expr2 b-B
  name Expression12
  label "translate Pworld to camera"
  xpos 248
  ypos 11
 }
set N63490360 [stack 0]
 Premult {
  name Premult6
  xpos 3
  ypos 36
 }
 Multiply {
  channels rgb
  value -1
  name Multiply12
  label "cam to surface ray direction"
  xpos 3
  ypos 68
 }
 Expression {
  temp_name0 camx
  temp_expr0 Axis1.world_matrix.3
  temp_name1 camy
  temp_expr1 Axis1.world_matrix.7
  temp_name2 camz
  temp_expr2 Axis1.world_matrix.11
  expr0 sqrt((camx*r)+(camy*g)+(camz*b))
  expr1 0
  expr2 0
  name VectorLength5
  xpos 3
  ypos 110
 }
 Dot {
  name Dot5
  xpos 471
  ypos 1626
 }
push $N63490360
 ColorMatrix {
  matrix {
      {{"\[value \[topnode this.parent.input3].world_matrix.0]"} {"\[value \[topnode this.parent.input3].world_matrix.1]"} {"\[value \[topnode this.parent.input3].world_matrix.2]"}}
      {{"\[value \[topnode this.parent.input3].world_matrix.4]"} {"\[value \[topnode this.parent.input3].world_matrix.5]"} {"\[value \[topnode this.parent.input3].world_matrix.6]"}}
      {{"\[value \[topnode this.parent.input3].world_matrix.8]"} {"\[value \[topnode this.parent.input3].world_matrix.9]"} {"\[value \[topnode this.parent.input3].world_matrix.10]"}}
    }
  invert true
  name ColorMatrix5
  label "Rotate to camera"
  xpos 248
  ypos 49
 }
 Multiply {
  channels {-rgba.red -rgba.green rgba.blue none}
  value -1
  name Multiply13
  label "reverse Z"
  xpos 248
  ypos 109
 }
 Premult {
  name Premult7
  xpos 248
  ypos 142
 }
 Expression {
  expr2 b<0?0:b
  name Expression15
  label "clip Z behind cam"
  xpos 248
  ypos 207
 }
set N8047a5e0 [stack 0]
 Expression {
  temp_name0 h_tan
  temp_expr0 "(\[value \[topnode this.parent.input3].haperture] /2) / \[value \[topnode this.parent.input3].focal]"
  temp_name1 v_tan
  temp_expr1 "(\[value \[topnode this.parent.input3].vaperture] /2)  / \[value \[topnode this.parent.input3].focal]"
  expr0 "0.5 + 0.5 * r / h_tan / b"
  expr1 "0.5 + 0.5 * g / v_tan / b"
  expr2 0
  channel3 {none none none -rgba.alpha}
  name Expression14
  label CameraUVs
  xpos 576
  ypos 1180
  addUserKnob {20 "" l User}
 }
set N7bfadbb0 [stack 0]
 Expression {
  expr3 "(r<0 || r>1 || g<0 || g>1)?0:a"
  name Expression11
  label "clamp projection to cam frustum"
  xpos 588
  ypos 1261
  disable {{!crop_to_frustum}}
 }
 Dot {
  name Dot11
  xpos 734
  ypos 1479
 }
set Nab603ba0 [stack 0]
 Dot {
  name Dot18
  xpos 643
  ypos 1483
 }
 Dot {
  name Dot12
  xpos 643
  ypos 1579
 }
push $Nab603ba0
 Input {
  inputs 0
  name shadow
  label "\[value number]"
  xpos 458
  ypos -347
  number 1
 }
 Shuffle {
  in none
  alpha white
  out rgb
  name ShufflePshad
  label "no alpha required"
  xpos 458
  ypos -155
 }
 Expression {
  temp_name0 camx
  temp_expr0 Axis1.world_matrix.3
  temp_name1 camy
  temp_expr1 Axis1.world_matrix.7
  temp_name2 camz
  temp_expr2 Axis1.world_matrix.11
  expr0 camx-r
  expr1 camy-g
  expr2 camz-b
  name Expression18
  label "cam to surface ray direction"
  xpos 458
  ypos 53
 }
 Expression {
  temp_name0 camx
  temp_expr0 Axis1.world_matrix.3
  temp_name1 camy
  temp_expr1 Axis1.world_matrix.7
  temp_name2 camz
  temp_expr2 Axis1.world_matrix.11
  expr0 sqrt((camx*r)+(camy*g)+(camz*b))
  expr1 0
  expr2 0
  name VectorLength6
  xpos 458
  ypos 118
 }
 Dot {
  name Dot8
  xpos 1152
  ypos 1506
 }
 STMap {
  inputs 2
  channels {rgba.red -rgba.green -rgba.blue none}
  uv rgb
  blur -rgba.alpha
  blur_scale 0
  maskChannel -rgba.alpha
  name STMap3
  label "warp Pshad"
  xpos 700
  ypos 1521
 }
 CopyBBox {
  inputs 2
  name CopyBBox4
  xpos 700
  ypos 1601
 }
 MergeExpression {
  inputs 2
  expr0 "step(Ar, Br+bias)"
  channel1 {-rgba.red -rgba.green -rgba.blue none}
  channel2 {-rgba.red -rgba.green -rgba.blue none}
  channel3 {none none none -rgba.alpha}
  name MergeExpression3
  label "Step depthtest"
  xpos 700
  ypos 1640
  addUserKnob {20 User}
  addUserKnob {7 bias}
  bias {{parent.bias i}}
 }
 ChannelMerge {
  inputs 2
  operation max
  B rgba.red
  output rgba.red
  name ChannelMerge1
  label "clean shadow edges"
  xpos 700
  ypos 1779
 }
 Expression {
  expr0 step(0,r)
  channel1 {-rgba.red -rgba.green -rgba.blue none}
  channel2 {-rgba.red -rgba.green -rgba.blue none}
  channel3 {none none none -rgba.alpha}
  name Expression19
  label "step (clean edges)"
  xpos 700
  ypos 1847
 }
 Bilateral {
  Size 1
  PositionalSigma 2
  ColorSigma 2
  name Bilateral1
  xpos 700
  ypos 1906
  disable {{!smooth i}}
 }
 Gamma {
  channels {rgba.red -rgba.green -rgba.blue none}
  value 0.45
  name Gamma2
  xpos 700
  ypos 1960
 }
push $N833938f0
 Dot {
  name Dot6
  xpos -572
  ypos 998
 }
push $N8047a5e0
 Dot {
  name Dot2
  label "nuke cam"
  xpos 544
  ypos 624
 }
 Expression {
  temp_name0 h_tan
  temp_expr0 "(\[value \[topnode this.parent.input3].haperture] /2) / \[value \[topnode this.parent.input3].focal]"
  temp_name1 v_tan
  temp_expr1 "(\[value \[topnode this.parent.input3].vaperture] /2)  / \[value \[topnode this.parent.input3].focal]"
  expr0 "0.5 + 0.5 * r / h_tan / b"
  expr1 "0.5 + 0.5 * g / v_tan / b"
  expr2 0
  channel3 {none none none -rgba.alpha}
  name Expression16
  label CameraUVs
  xpos 566
  ypos 705
  addUserKnob {20 "" l User}
 }
 Expression {
  expr3 "(r<0 || r>1 || g<0 || g>1)?0:a"
  name Expression17
  label "clamp projection to cam frustum"
  xpos 566
  ypos 743
  disable {{!crop_to_frustum}}
 }
 Dot {
  name Dot1
  xpos -203
  ypos 858
 }
set N634b5870 [stack 0]
push $N634b5870
 Input {
  inputs 0
  name img
  label "\[value number]"
  xpos -410
  ypos -542
  number 2
 }
 Expression {
  expr0 x/width
  expr1 y/height
  expr2 0
  name Expression8
  label UVs
  xpos -410
  ypos -453
  disable {{!outputUVs i}}
 }
 Dot {
  name Dot3
  xpos -376
  ypos 598
 }
 Colorspace {
  colorspace_out AlexaV3LogC
  name Colorspace1
  label "\[value colorspace_in] >> \[value colorspace_out]"
  xpos -410
  ypos 691
  disable {{!parent.transformInLog}}
 }
 STMap {
  inputs 2
  uv rgb
  blur -rgba.alpha
  blur_scale 0
  maskChannel -rgba.alpha
  name STMap1
  xpos -410
  ypos 761
 }
set Nabda5c80 [stack 0]
 Dot {
  name Dot4
  xpos -275
  ypos 876
 }
push $Nabda5c80
 Shuffle {
  alpha white
  name Shuffle6
  xpos -439
  ypos 822
 }
 Colorspace {
  colorspace_in AlexaV3LogC
  name Colorspace2
  label "\[value colorspace_in] >> \[value colorspace_out]"
  xpos -425
  ypos 852
  disable {{!parent.transformInLog}}
 }
 Multiply {
  inputs 1+1
  channels alpha
  value 0
  invert_mask true
  name Multiply7
  xpos -410
  ypos 903
  disable {{"!\[value . maskChannelMask]"}}
 }
 Premult {
  channels all
  name Premult1
  label "by projected matte"
  xpos -410
  ypos 960
 }
 Multiply {
  inputs 1+1
  value 0
  invert_mask true
  name Multiply1
  label "cam frustum"
  xpos -410
  ypos 1023
 }
 Multiply {
  inputs 1+1
  value {{"\[value . maskChannelMask]>0?0:1" i}}
  invert_mask true
  name Multiply3
  label "by surface alpha"
  xpos -410
  ypos 1079
 }
set N62ec3740 [stack 0]
 Multiply {
  inputs 1+1
  value {{"\[value . maskChannelMask]>0?0:1" i}}
  maskChannelMask rgba.red
  invert_mask true
  name Multiply4
  xpos -410
  ypos 1996
  disable {{!parent.zdepth_shadow i}}
 }
 Multiply {
  inputs 1+1
  value 0
  maskChannelMask rgba.red
  invert_mask true
  name Multiply5
  xpos -410
  ypos 2077
  disable {{!front_facing_only}}
 }
 CopyBBox {
  inputs 2
  name CopyBBox1
  xpos -410
  ypos 2204
 }
 CopyMetaData {
  inputs 2
  name CopyMetaData1
  xpos -410
  ypos 2259
 }
 Output {
  name Output1
  xpos -410
  ypos 2319
 }
 Input {
  inputs 0
  name cam
  label "\[value number]"
  xpos -177
  ypos -537
  number 3
 }
push $N7bfadbb0
push $N62ec3740
 Viewer {
  inputs 2
  frame 1081
  frame_range 1001-1129
  viewerProcess "None (default)"
  input_process false
  name Viewer1
  xpos 462
  ypos 260
 }
end_group
