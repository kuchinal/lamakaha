set cut_paste_input [stack 0]
version 6.3 v4
push 0
push $cut_paste_input
Group {
 inputs 2
 name Ambient_light
 help "Lights the CG using the normals pass and an HDR lightprobe of the set.\n\n- Connect the node to an appropriate lightprobe.\n- Connect the CG normal pass.\n- Press \"Compute Coefficients\". This will take a few seconds.\n- Combine this with the ambient occlusion pass for proper shadowing.\n\nIMPORTANT: the lightprobe  has to be a square angular map (e.g. the HDR version of the chrome ball )."
 tile_color 0x3900ff
 note_font "Verdana Bold"
 note_font_size 14
 note_font_color 0xffffffff
 selected true
 xpos -225
 ypos 342
 mapsize {0.15 0.15}
 addUserKnob {20 Irradiance l AO}
 addUserKnob {22 Compute_Coefficients l " Compute" T "from nukescripts import cache_clear \t\t#I need to do this as if I don't the sampling is done on a cache and for some reason the results are all zeroed.\ncache_clear(\"\") \n\nimport math\nPI = math.pi\n\nmyClose=0\n\ndef sinc(x):    \n    if (math.fabs(x) < 0.0001):\n        return 1.0\n    else :\n        return(math.sin(x)/x)\t\t\t# supporting sinc function\n\ncoeffs=\[\[0 for COL in range(3)] for L in range(9)]\nw=0\ni=0\nj=0\nk=0\np=0\nu=0\nv=0\n\n# check if probe is a square angular map.\n\nmyNode= nuke.thisNode()\t\t\t# get selected node\nfor t in myNode.nodes() : \n    if t.name() == 'LightProbe':\n        tmpW =  int(nuke.value(t.name()+\".format.w\")) \n        tmpH =  int(nuke.value(t.name()+\".format.h\"))\n        if tmpW!=tmpH:\n            nuke.message('The HDR map you are using is not in the right format. Please use a square angular map.')\n            myClose=1\n\nfor a in myNode.nodes() : \n    if a.name() == 'Reformat_IBL':\n        sn = a\n                                       \nw = int(nuke.value(sn.name()+\".format.w\"))    \t# get probe width\n\nhdr = \[\[\[0 for COL in range(3)] for Y in range(w)] for X in range(w)]\n\nfor i in range (w):\n    if myClose == 1:\n        break\t\t\t\t#if probe isn't square stop\n    for j in range (w):\n\n        hdr\[i]\[j]\[0]= sn.sample(\"r\", i, j)\t\t#sample probe and fill hdr array\n        hdr\[i]\[j]\[1]= sn.sample(\"g\", i, j)\n        hdr\[i]\[j]\[2]= sn.sample(\"b\", i, j)\n\n# The prefiltering routine.  \n\nfor k in range (w):\n    if myClose == 1:\n        break\t\t\t\t#if probe isn't square stop\n    for p in range (w):\n        # find the cartesian components for the point (i,j) \n    \n        v = (w/2.0 - k)/(w/2.0)\t\t\t# v ranges from -1 to 1 \n        u = (p - w/2.0)/(w/2.0)\t\t\t# u ranges from -1 to 1 \n        r = math.sqrt(u*u+v*v)\t\t\t# The \"radius\" \n        if r > 1.0:\n            continue\t\t\t# Consider only circle with r<1 \n    \n        theta = PI * r\t\t\t# theta parameter of (i,j) \n        phi = math.atan2(v,u)\t\t\t# phi parameter \n    \n        x = math.sin(theta)*math.cos(phi)\t\t# Cartesian components \n        y = math.sin(theta)*math.sin(phi)  \n        z = math.cos(theta)\n            \n        domega = (2*PI/w)*(2*PI/w)* sinc(theta)\t# Computation of the solid angle.  \n    \n        # Update the coefficients (i.e. compute the next term in the\n        # integral) based on the lighting value hdr\[3], the differential\n        # solid angle domega and cartesian components of surface normal x,y,z\n    \n        for col in range (3):\n            \n            # L_\{00\}.  Note that Y_\{00\} = 0.282095\n            c = 0.282095\n            coeffs\[0]\[col] += hdr\[k]\[p]\[col]*c*domega\n    \n            # L_\{1m\}. -1 <= m <= 1.  The linear terms\n            c = 0.488603\n            coeffs\[1]\[col] += hdr\[k]\[p]\[col]*(c*y)*domega\n            coeffs\[2]\[col] += hdr\[k]\[p]\[col]*(c*z)*domega\n            coeffs\[3]\[col] += hdr\[k]\[p]\[col]*(c*x)*domega\n    \n            # The Quadratic terms, L_\{2m\} -2 <= m <= 2\n    \n            # First, L_\{2-2\}, L_\{2-1\}, L_\{21\} corresponding to xy,yz,xz\n            c = 1.092548\n            coeffs\[4]\[col] += hdr\[k]\[p]\[col]*(c*x*y)*domega\n            coeffs\[5]\[col] += hdr\[k]\[p]\[col]*(c*y*z)*domega\n            coeffs\[7]\[col] += hdr\[k]\[p]\[col]*(c*x*z)*domega\n    \n            # L_\{20\}.  Note that Y_\{20\} = 0.315392 (3z^2 - 1)\n            c = 0.315392\n            coeffs\[6]\[col] += hdr\[k]\[p]\[col]*(c*(3*z*z-1))*domega\n    \n            # L_\{22\}.  Note that Y_\{22\} = 0.546274 (x^2 - y^2)\n            c = 0.546274\n            coeffs\[8]\[col] += hdr\[k]\[p]\[col]*(c*(x*x-y*y))*domega\n\n# store the coefficients in the gizmo for rendering.\nmyNode\['L00'].setValue(\"%0.2f\" % float(coeffs\[0]\[0]/3.2))\nmyNode\['L00_1'].setValue(\"%0.2f\" % float(coeffs\[0]\[1]/3.2))\nmyNode\['L00_2'].setValue(\"%0.2f\" % float(coeffs\[0]\[2]/3.2))\nmyNode\['L1_1'].setValue(\"%0.2f\" % float(coeffs\[3]\[0]/3.2))\nmyNode\['L1_1_1'].setValue(\"%0.2f\" % float(coeffs\[3]\[1]/3.2))\nmyNode\['L1_1_2'].setValue(\"%0.2f\" % float(coeffs\[3]\[2]/3.2))\nmyNode\['L10'].setValue(\"%0.2f\" % float(coeffs\[2]\[0]/3.2))\nmyNode\['L10_1'].setValue(\"%0.2f\" % float(coeffs\[2]\[1]/3.2))\nmyNode\['L10_2'].setValue(\"%0.2f\" % float(coeffs\[2]\[2]/3.2))\nmyNode\['L11'].setValue(\"%0.2f\" % float(-coeffs\[1]\[0]/3.2))\nmyNode\['L11_1'].setValue(\"%0.2f\" % float(-coeffs\[1]\[1]/3.2))\nmyNode\['L11_2'].setValue(\"%0.2f\" % float(-coeffs\[1]\[2]/3.2))\nmyNode\['L2_2'].setValue(\"%0.2f\" % float(-coeffs\[4]\[0]/3.2))\nmyNode\['L2_2_1'].setValue(\"%0.2f\" % float(-coeffs\[4]\[1]/3.2))\nmyNode\['L2_2_2'].setValue(\"%0.2f\" % float(-coeffs\[4]\[2]/3.2))\nmyNode\['L2_1'].setValue(\"%0.2f\" % float(coeffs\[7]\[0]/3.2))\nmyNode\['L2_1_1'].setValue(\"%0.2f\" % float(coeffs\[7]\[1]/3.2))\nmyNode\['L2_1_2'].setValue(\"%0.2f\" % float(coeffs\[7]\[2]/3.2))\nmyNode\['L20'].setValue(\"%0.2f\" % float(coeffs\[6]\[0]/3.2))\nmyNode\['L20_1'].setValue(\"%0.2f\" % float(coeffs\[6]\[1]/3.2))\nmyNode\['L20_2'].setValue(\"%0.2f\" % float(coeffs\[6]\[2]/3.2))\nmyNode\['L21'].setValue(\"%0.2f\" % float(-coeffs\[5]\[0]/3.2))\nmyNode\['L21_1'].setValue(\"%0.2f\" % float(-coeffs\[5]\[1]/3.2))\nmyNode\['L21_2'].setValue(\"%0.2f\" % float(-coeffs\[5]\[2]/3.2))\nmyNode\['L22'].setValue(\"%0.2f\" % float(-coeffs\[8]\[0]/3.2))\nmyNode\['L22_1'].setValue(\"%0.2f\" % float(-coeffs\[8]\[1]/3.2))\nmyNode\['L22_2'].setValue(\"%0.2f\" % float(-coeffs\[8]\[2]/3.2))" +STARTLINE}
 addUserKnob {26 DomeOrientation l "Dome Rotation"}
 addUserKnob {7 X R -180 180}
 addUserKnob {7 Y R -180 180}
 addUserKnob {7 Z R -180 180}
 addUserKnob {20 Red l INVISIBLE +INVISIBLE n 1}
 addUserKnob {1 L00 l INVISIBLE -STARTLINE +INVISIBLE}
 L00 0.00
 addUserKnob {1 L1_1 l INVISIBLE -STARTLINE +INVISIBLE}
 L1_1 0.00
 addUserKnob {1 L10 l INVISIBLE -STARTLINE +INVISIBLE}
 L10 0.00
 addUserKnob {1 L11 l INVISIBLE -STARTLINE +INVISIBLE}
 L11 0.00
 addUserKnob {1 L2_2 l INVISIBLE +INVISIBLE}
 L2_2 0.00
 addUserKnob {1 L2_1 l INVISIBLE -STARTLINE +INVISIBLE}
 L2_1 0.00
 addUserKnob {1 L20 l INVISIBLE -STARTLINE +INVISIBLE}
 L20 0.00
 addUserKnob {1 L21 l INVISIBLE -STARTLINE +INVISIBLE}
 L21 0.00
 addUserKnob {1 L22 l INVISIBLE +INVISIBLE}
 L22 0.00
 addUserKnob {20 endGroup n -1}
 addUserKnob {20 Green l INVISIBLE +INVISIBLE n 1}
 Green 0
 addUserKnob {1 L00_1 l INVISIBLE +INVISIBLE}
 L00_1 0.00
 addUserKnob {1 L1_1_1 l INVISIBLE +INVISIBLE}
 L1_1_1 0.00
 addUserKnob {1 L10_1 l INVISIBLE +INVISIBLE}
 L10_1 0.00
 addUserKnob {1 L11_1 l INVISIBLE +INVISIBLE}
 L11_1 0.00
 addUserKnob {1 L2_2_1 l INVISIBLE +INVISIBLE}
 L2_2_1 0.00
 addUserKnob {1 L2_1_1 l INVISIBLE +INVISIBLE}
 L2_1_1 0.00
 addUserKnob {1 L20_1 l INVISIBLE +INVISIBLE}
 L20_1 0.00
 addUserKnob {1 L21_1 l INVISIBLE +INVISIBLE}
 L21_1 0.00
 addUserKnob {1 L22_1 l INVISIBLE +INVISIBLE}
 L22_1 0.00
 addUserKnob {20 endGroup_1 l "" +STARTLINE n -1}
 addUserKnob {20 Blue l INVISIBLE +INVISIBLE n 1}
 Blue 0
 addUserKnob {1 L00_2 l INVISIBLE +INVISIBLE}
 L00_2 0.00
 addUserKnob {1 L1_1_2 l INVISIBLE +INVISIBLE}
 L1_1_2 0.00
 addUserKnob {1 L10_2 l INVISIBLE +INVISIBLE}
 L10_2 0.00
 addUserKnob {1 L11_2 l INVISIBLE +INVISIBLE}
 L11_2 0.00
 addUserKnob {1 L2_2_2 l INVISIBLE +INVISIBLE}
 L2_2_2 0.00
 addUserKnob {1 L2_1_2 l INVISIBLE +INVISIBLE}
 L2_1_2 0.00
 addUserKnob {1 L20_2 l INVISIBLE +INVISIBLE}
 L20_2 0.00
 addUserKnob {1 L21_2 l INVISIBLE +INVISIBLE}
 L21_2 0.00
 addUserKnob {1 L22_2 l INVISIBLE +INVISIBLE}
 L22_2 0.00
 addUserKnob {20 endGroup_2 l INVISIBLE +INVISIBLE n -1}
}
 BackdropNode {
  inputs 0
  name ORIENTATION
  tile_color 0x61806000
  xpos 159
  ypos 241
  bdwidth 185
  bdheight 152
 }
 Input {
  inputs 0
  name LightProbe
  selected true
  xpos 385
  ypos 189
  number 1
 }
 Reformat {
  format "256 256 0 0 256 256 1 square_256"
  center false
  name Reformat_IBL
  xpos 385
  ypos 307
 }
 Input {
  inputs 0
  name N
  xpos 210
  ypos 189
 }

 Expression {
  temp_name0 inputZ
  temp_expr0 parent.Z
  temp_name1 sigma
  temp_expr1 radians(inputZ)
  expr0 "cos(sigma)*r + sin(sigma)*g"
  expr1 "-sin(sigma)*r + cos(sigma)*g"
  name ROT_Z
  xpos 210
  ypos 289
 }
 Expression {
  temp_name0 inputX
  temp_expr0 parent.X
  temp_name1 theta
  temp_expr1 radians(inputX)
  expr1 "cos(theta)*g + sin(theta)*b"
  expr2 "-sin(theta)*g + cos(theta)*b"
  name ROT_X
  xpos 210
  ypos 314
 }
 Expression {
  temp_name0 inputY
  temp_expr0 parent.Y
  temp_name1 epsilon
  temp_expr1 radians(inputY)
  expr0 "cos(epsilon)*r - sin(epsilon)*b"
  expr2 "sin(epsilon)*r + cos(epsilon)*b"
  name ROT_Y
  xpos 210
  ypos 339
 }
 Expression {
  expr0 0.429043*parent.L22*(pow2(r)-pow2(g))+(0.743125*parent.L20*pow2(b))+0.886227*parent.L00-(0.247708*parent.L20)+2*0.429043*((parent.L2_2*r*g)+(parent.L21*r*b)+(parent.L2_1*g*b))+2*0.511664*((parent.L11*r)+(parent.L1_1*g)+(parent.L10*b))
  expr1 0.429043*parent.L22_1*(pow2(r)-pow2(g))+(0.743125*parent.L20_1*pow2(b))+0.886227*parent.L00_1-(0.247708*parent.L20_1)+2*0.429043*((parent.L2_2_1*r*g)+(parent.L21_1*r*b)+(parent.L2_1_1*g*b))+2*0.511664*((parent.L11_1*r)+(parent.L1_1_1*g)+(parent.L10_1*b))
  expr2 0.429043*parent.L22_2*(pow2(r)-pow2(g))+(0.743125*parent.L20_2*pow2(b))+0.886227*parent.L00_2-(0.247708*parent.L20_2)+2*0.429043*((parent.L2_2_2*r*g)+(parent.L21_2*r*b)+(parent.L2_1_2*g*b))+2*0.511664*((parent.L11_2*r)+(parent.L1_1_2*g)+(parent.L10_2*b))
  expr3 a
  name Irradiance_RENDERER
  tile_color 0xc6595900
  xpos 210
  ypos 414
 }
 Clamp {
  channels rgba
  maximum_enable false
  name CLAMP_BLACKS3
  tile_color 0x7aa9ff00
  xpos 210
  ypos 464
 }
 Output {
  name Output1
  xpos 210
  ypos 539
 }
end_group
